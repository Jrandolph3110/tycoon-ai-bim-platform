/**
 * Phase 2 Implementation Test Suite
 * 
 * Validates all Phase 2 enhancements:
 * - Enhanced reliability with error recovery
 * - Load testing infrastructure (10k lines/sec)
 * - Operational monitoring with KPI dashboard
 * - Security enhancements with WSS and access controls
 */

import { LoadTestingFramework } from './dist/testing/LoadTestingFramework.js';
import { OperationalMonitor } from './dist/monitoring/OperationalMonitor.js';
import { SecurityLayer } from './dist/security/SecurityLayer.js';
import { NetworkRecoveryManager } from './dist/streaming/ErrorRecoveryManager.js';
import chalk from 'chalk';

class Phase2TestSuite {
    constructor() {
        this.loadTester = new LoadTestingFramework();
        this.operationalMonitor = new OperationalMonitor();
        this.securityLayer = new SecurityLayer({
            enableTLS: false,
            enableUserAuth: true,
            enableAuditLogging: true,
            enablePiiRedaction: true,
            complianceMode: 'gdpr',
            sessionTimeoutMinutes: 60,
            maxFailedAttempts: 5,
            rateLimitRequestsPerMinute: 100
        });
        this.networkRecovery = new NetworkRecoveryManager({
            maxRetries: 5,
            initialDelayMs: 1000,
            maxDelayMs: 30000,
            backoffMultiplier: 2,
            jitterEnabled: true
        }, true);
    }

    async runAllTests() {
        console.log(chalk.blue.bold('\nüöÄ PHASE 2 IMPLEMENTATION TEST SUITE\n'));
        console.log(chalk.green('Testing enhanced resilience, load testing, monitoring, and security...\n'));

        const results = {
            loadTesting: false,
            errorRecovery: false,
            operationalMonitoring: false,
            securityLayer: false,
            overallSuccess: false
        };

        try {
            // Test 1: Load Testing Infrastructure
            console.log(chalk.yellow('üìä Test 1: Load Testing Infrastructure'));
            results.loadTesting = await this.testLoadTesting();
            console.log(results.loadTesting ? 
                chalk.green('‚úÖ Load testing: PASSED') : 
                chalk.red('‚ùå Load testing: FAILED'));

            // Test 2: Error Recovery Mechanisms
            console.log(chalk.yellow('\nüîÑ Test 2: Error Recovery Mechanisms'));
            results.errorRecovery = await this.testErrorRecovery();
            console.log(results.errorRecovery ? 
                chalk.green('‚úÖ Error recovery: PASSED') : 
                chalk.red('‚ùå Error recovery: FAILED'));

            // Test 3: Operational Monitoring
            console.log(chalk.yellow('\nüìà Test 3: Operational Monitoring'));
            results.operationalMonitoring = await this.testOperationalMonitoring();
            console.log(results.operationalMonitoring ? 
                chalk.green('‚úÖ Operational monitoring: PASSED') : 
                chalk.red('‚ùå Operational monitoring: FAILED'));

            // Test 4: Security Layer
            console.log(chalk.yellow('\nüîí Test 4: Security Layer'));
            results.securityLayer = await this.testSecurityLayer();
            console.log(results.securityLayer ? 
                chalk.green('‚úÖ Security layer: PASSED') : 
                chalk.red('‚ùå Security layer: FAILED'));

            // Overall results
            results.overallSuccess = Object.values(results).every(r => r === true);
            
            console.log(chalk.blue.bold('\nüìã PHASE 2 TEST RESULTS:'));
            console.log(`Load Testing: ${results.loadTesting ? '‚úÖ' : '‚ùå'}`);
            console.log(`Error Recovery: ${results.errorRecovery ? '‚úÖ' : '‚ùå'}`);
            console.log(`Operational Monitoring: ${results.operationalMonitoring ? '‚úÖ' : '‚ùå'}`);
            console.log(`Security Layer: ${results.securityLayer ? '‚úÖ' : '‚ùå'}`);
            console.log(`\nOverall Success: ${results.overallSuccess ? '‚úÖ PASSED' : '‚ùå FAILED'}`);

            if (results.overallSuccess) {
                console.log(chalk.green.bold('\nüéâ PHASE 2 IMPLEMENTATION: ALL TESTS PASSED!'));
                console.log(chalk.green('‚úÖ Enhanced resilience and flow control ready for production'));
                console.log(chalk.green('‚úÖ Load testing infrastructure validated'));
                console.log(chalk.green('‚úÖ Operational monitoring with KPI dashboard active'));
                console.log(chalk.green('‚úÖ Security enhancements with access controls implemented'));
            } else {
                console.log(chalk.red.bold('\n‚ùå PHASE 2 IMPLEMENTATION: SOME TESTS FAILED'));
                console.log(chalk.yellow('‚ö†Ô∏è Review failed components before proceeding to Phase 3'));
            }

        } catch (error) {
            console.error(chalk.red('\nüí• Test suite execution failed:'), error);
            results.overallSuccess = false;
        }

        return results;
    }

    async testLoadTesting() {
        try {
            console.log('  üîß Initializing load testing framework...');
            
            const config = {
                targetLinesPerSecond: 1000, // Reduced for testing
                durationSeconds: 5,         // Short test duration
                concurrentStreams: 3,
                logLineSize: 200,
                memoryPressureTest: true,
                networkFlapTest: true,
                lowSpecHardwareTest: true
            };

            console.log('  ‚ö° Running load test...');
            const results = await this.loadTester.runLoadTest(config);
            
            console.log('  üìä Load test results:');
            console.log(`    ‚Ä¢ Throughput: ${results.throughputLinesPerSecond.toFixed(2)} lines/sec`);
            console.log(`    ‚Ä¢ Memory usage: ${results.memoryUsageMB.toFixed(2)} MB`);
            console.log(`    ‚Ä¢ CPU usage: ${results.cpuUsagePercent.toFixed(2)}%`);
            console.log(`    ‚Ä¢ Dropped messages: ${results.droppedMessages}`);
            console.log(`    ‚Ä¢ Network flaps: ${results.networkFlaps}`);

            // Success criteria
            const throughputOk = results.throughputLinesPerSecond >= 500; // Reduced threshold for testing
            const memoryOk = results.memoryUsageMB < 200; // 200MB limit
            const cpuOk = results.cpuUsagePercent < 10; // 10% limit for testing
            const droppedOk = results.droppedMessages < 100;

            return throughputOk && memoryOk && cpuOk && droppedOk;

        } catch (error) {
            console.error('    ‚ùå Load testing failed:', error.message);
            return false;
        }
    }

    async testErrorRecovery() {
        try {
            console.log('  üîß Testing network recovery manager...');
            
            // Initialize recovery for test stream
            const streamId = 'test-stream-001';
            this.networkRecovery.initializeStreamRecovery(streamId, 0);
            
            console.log('  üîÑ Testing connection recovery...');
            
            // Simulate connection drop and recovery
            let recoverySuccessful = false;
            await this.networkRecovery.handleConnectionDrop(streamId, async () => {
                // Simulate successful reconnection
                recoverySuccessful = true;
                console.log('    ‚úÖ Connection recovered successfully');
            });

            // Get recovery metrics
            const metrics = this.networkRecovery.getRecoveryMetrics(streamId);
            console.log('  üìä Recovery metrics:');
            console.log(`    ‚Ä¢ Stream ID: ${metrics?.streamId || 'N/A'}`);
            console.log(`    ‚Ä¢ Failure count: ${metrics?.failureCount || 0}`);
            console.log(`    ‚Ä¢ Is recovering: ${metrics?.isRecovering || false}`);
            console.log(`    ‚Ä¢ Success rate: ${((metrics?.successRate || 0) * 100).toFixed(1)}%`);

            // Cleanup
            this.networkRecovery.cleanupStreamRecovery(streamId);

            return recoverySuccessful && metrics !== null;

        } catch (error) {
            console.error('    ‚ùå Error recovery testing failed:', error.message);
            return false;
        }
    }

    async testOperationalMonitoring() {
        try {
            console.log('  üîß Testing operational monitoring...');
            
            // Start monitoring
            this.operationalMonitor.startMonitoring(1000); // 1-second intervals for testing
            
            // Wait for some metrics to be collected
            await new Promise(resolve => setTimeout(resolve, 3000));
            
            console.log('  üìä Getting KPI dashboard...');
            const dashboard = this.operationalMonitor.getKPIDashboard();
            
            console.log('  üìà Dashboard metrics:');
            console.log(`    ‚Ä¢ Timestamp: ${dashboard.timestamp}`);
            console.log(`    ‚Ä¢ Health status: ${dashboard.healthStatus?.overall || 'unknown'}`);
            console.log(`    ‚Ä¢ Active alerts: ${dashboard.activeAlerts || 0}`);
            console.log(`    ‚Ä¢ Critical alerts: ${dashboard.criticalAlerts || 0}`);

            // Test metrics history
            const history = this.operationalMonitor.getMetricsHistory(1);
            console.log(`    ‚Ä¢ Metrics history entries: ${history.length}`);

            // Test operational report
            const report = this.operationalMonitor.generateOperationalReport(1);
            console.log(`    ‚Ä¢ Report ID: ${report.reportId}`);
            console.log(`    ‚Ä¢ Recommendations: ${report.recommendations.length}`);

            // Stop monitoring
            this.operationalMonitor.stopMonitoring();

            return dashboard !== null && history.length > 0 && report !== null;

        } catch (error) {
            console.error('    ‚ùå Operational monitoring testing failed:', error.message);
            return false;
        }
    }

    async testSecurityLayer() {
        try {
            console.log('  üîß Testing security layer...');
            
            // Test user authentication
            console.log('  üîê Testing user authentication...');
            const session = await this.securityLayer.authenticateUser(
                'admin', 'admin123', '127.0.0.1', 'test-agent'
            );
            
            if (!session) {
                console.error('    ‚ùå Authentication failed');
                return false;
            }
            
            console.log(`    ‚úÖ User authenticated: ${session.userId}`);
            console.log(`    ‚Ä¢ Session ID: ${session.sessionId}`);
            console.log(`    ‚Ä¢ Permissions: ${Array.from(session.permissions).join(', ')}`);

            // Test access validation
            console.log('  üîç Testing access validation...');
            const accessResult = this.securityLayer.validateAccess(session.sessionId, 'tycoon');
            console.log(`    ‚Ä¢ Access valid: ${accessResult.valid}`);

            // Test PII redaction
            console.log('  üõ°Ô∏è Testing PII redaction...');
            const testLog = 'User john.doe@example.com with SSN 123-45-6789 accessed system';
            const redactedLog = this.securityLayer.processLogEntry(testLog, session.sessionId);
            console.log(`    ‚Ä¢ Original: ${testLog}`);
            console.log(`    ‚Ä¢ Redacted: ${redactedLog}`);
            
            const piiRedacted = redactedLog.includes('[REDACTED]');
            console.log(`    ‚Ä¢ PII redaction working: ${piiRedacted ? '‚úÖ' : '‚ùå'}`);

            // Test security metrics
            console.log('  üìä Testing security metrics...');
            const securityMetrics = this.securityLayer.getSecurityMetrics();
            console.log(`    ‚Ä¢ Active sessions: ${securityMetrics.activeSessions}`);
            console.log(`    ‚Ä¢ TLS enabled: ${securityMetrics.tlsEnabled}`);
            console.log(`    ‚Ä¢ Compliance mode: ${securityMetrics.complianceMode}`);

            // Logout
            const logoutSuccess = this.securityLayer.logout(session.sessionId);
            console.log(`    ‚Ä¢ Logout successful: ${logoutSuccess ? '‚úÖ' : '‚ùå'}`);

            return accessResult.valid && piiRedacted && logoutSuccess;

        } catch (error) {
            console.error('    ‚ùå Security layer testing failed:', error.message);
            return false;
        }
    }
}

// Run the test suite
async function main() {
    const testSuite = new Phase2TestSuite();
    const results = await testSuite.runAllTests();
    
    // Exit with appropriate code
    process.exit(results.overallSuccess ? 0 : 1);
}

// Handle unhandled rejections
process.on('unhandledRejection', (reason, promise) => {
    console.error(chalk.red('Unhandled Rejection at:'), promise, chalk.red('reason:'), reason);
    process.exit(1);
});

main().catch(error => {
    console.error(chalk.red('Test suite failed:'), error);
    process.exit(1);
});
